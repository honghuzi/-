# 排序算法
## 基于比较
冒泡 选择 插入，时间复杂度都是O(N^2)

### 冒泡
一遍一遍地扫，相邻的两个比较，一直到扫一遍都不用交换为止。
总迭代次数为N(N-1)/2

### 选择
扫一遍，每次找最小值，然后用最前面的一个去代替，实际上和冒泡类似。

### 插入
排扑克，新建一个队列，一张一张地加入已排好的队列中。
和数据有关，正序和反序时分别为O(N)和O(N^2).

### 归并
先对两部分排序，然后归并，即从两个里面选择较小的归并进来。
 
- 分而治之。 划分+解决
- 分治的过程可以用递归实现，最终变成两两比较
- 形式上和足球杯赛类似
- 有log(N)个级别，每个级别执行O(N)工作，因此总的时间复杂度为O(Nlog(N))。
- 这是最佳的基于比较的排序算法
- 是一种稳定排序算法
- 归并期间需要额外的O(N)存储，不是就地（in-place algorithm）排序

### 快速
分区总是分成相等的一半时，会有最佳情况，O(NlogN)
成功

### 随机快速
写法不一样，每次不是从小区域的开头开始分。因此总有O(NlogN)的复杂度。

## 不基于比较

### 计数排序
只适合少数几个数组成的数的排序

### 基数排序
比较数位，比完个位比十位，依此类推


Tags:
  排序, 算法